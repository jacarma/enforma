# MUI List Component Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement a MUI List component with card rows, modal create/edit/display, and draft-based form isolation.

**Architecture:** Extract `useListState` hook from core `List.tsx` so both core and MUI List share array/key/focus logic. Create `enforma-mui` `List` as a compound component (`List.Item`, `List.Form`) with MUI Dialog for CRUD, backed by an isolated draft `Form` store per open/close cycle.

**Tech Stack:** React 18, MUI v6, TypeScript strict, Vitest + @testing-library/react, enforma core

---

### Task 1: Extract `useListState` hook from core

**Files:**
- Create: `packages/enforma/src/hooks/useListState.ts`
- Modify: `packages/enforma/src/components/List.tsx`

**Step 1: Create `packages/enforma/src/hooks/useListState.ts`**

Move all logic from `List.tsx` into this file. Add a new `update` method.

```ts
// packages/enforma/src/hooks/useListState.ts
import { useRef } from 'react';
import { flushSync } from 'react-dom';
import { useFormValue } from '../context/ScopeContext';

export function useListState(bind: string, defaultItem: Record<string, unknown>) {
  const [rawArr, setArr] = useFormValue<unknown[]>(bind);
  const arr = rawArr ?? [];

  const keyCountRef = useRef(0);
  const keysRef = useRef<string[]>([]);
  const prevFocusRef = useRef<HTMLElement | null>(null);
  const containerRef = useRef<HTMLDivElement>(null);

  while (keysRef.current.length < arr.length) {
    keysRef.current.push(String(keyCountRef.current++));
  }
  if (keysRef.current.length > arr.length) {
    keysRef.current = keysRef.current.slice(0, arr.length);
  }

  const append = (item?: unknown): void => {
    keysRef.current.push(String(keyCountRef.current++));
    setArr([...arr, item ?? defaultItem]);
  };

  const remove = (index: number): void => {
    const mouseTarget = prevFocusRef.current;
    prevFocusRef.current = null;
    const newArr = arr.filter((_, i) => i !== index);
    keysRef.current = keysRef.current.filter((_, i) => i !== index);
    flushSync(() => {
      setArr(newArr);
    });
    if (mouseTarget !== null && document.body.contains(mouseTarget)) {
      mouseTarget.focus();
    } else if (containerRef.current !== null && newArr.length > 0) {
      const inputs = containerRef.current.querySelectorAll('input');
      const targetInput = inputs[Math.min(index, newArr.length - 1)];
      if (targetInput instanceof HTMLElement) {
        targetInput.focus();
      }
    }
  };

  const update = (index: number, item: unknown): void => {
    setArr(arr.map((v, i) => (i === index ? item : v)));
  };

  const handleMouseDown = (): void => {
    prevFocusRef.current =
      document.activeElement instanceof HTMLElement ? document.activeElement : null;
  };

  return { arr, keys: keysRef.current, containerRef, append, remove, update, handleMouseDown };
}
```

**Step 2: Refactor `packages/enforma/src/components/List.tsx` to use the hook**

Replace the entire file contents:

```tsx
// packages/enforma/src/components/List.tsx
import { type ReactNode } from 'react';
import { Scope } from './Scope';
import { useListState } from '../hooks/useListState';

type ListProps = {
  bind: string;
  defaultItem: Record<string, unknown>;
  children: ReactNode;
};

export function List({ bind, defaultItem, children }: ListProps) {
  const { arr, keys, containerRef, append, remove, handleMouseDown } = useListState(
    bind,
    defaultItem,
  );

  return (
    <Scope path={bind}>
      <div ref={containerRef}>
        {arr.map((_, index) => (
          <Scope key={keys[index] ?? String(index)} path={String(index)}>
            {children}
            <button
              type="button"
              onMouseDown={handleMouseDown}
              onClick={() => {
                remove(index);
              }}
            >
              Remove
            </button>
          </Scope>
        ))}
      </div>
      <button
        type="button"
        onClick={() => {
          append();
        }}
      >
        Add
      </button>
    </Scope>
  );
}
```

**Step 3: Run existing core List tests**

```bash
pnpm --filter enforma test -- List
```

Expected: all 8 tests in `List.test.tsx` pass. If any fail, the extraction introduced a bug — fix before continuing.

**Step 4: Export `useListState` from core**

In `packages/enforma/src/index.ts`, add after the existing exports:

```ts
export { useListState } from './hooks/useListState';
```

**Step 5: Run all core tests + typecheck**

```bash
pnpm --filter enforma test
pnpm --filter enforma typecheck
```

Expected: all tests pass, no TS errors.

**Step 6: Commit**

```bash
git add packages/enforma/src/hooks/useListState.ts \
        packages/enforma/src/components/List.tsx \
        packages/enforma/src/index.ts
git commit -m "refactor: extract useListState hook from core List, export it"
```

---

### Task 2: Create slot config components in `enforma-mui`

**Files:**
- Create: `packages/enforma-mui/src/components/ListItemSlot.tsx`
- Create: `packages/enforma-mui/src/components/ListFormSlot.tsx`

These are pure config components — they render `null` and only exist to carry typed props that the MUI `List` parent reads via `React.Children`.

**Step 1: Create `packages/enforma-mui/src/components/ListItemSlot.tsx`**

```tsx
// packages/enforma-mui/src/components/ListItemSlot.tsx
import { type FormValues } from 'enforma';

export type ListItemSlotProps = {
  title: string | ((item: FormValues) => string);
  subtitle?: string | ((item: FormValues) => string);
  avatar?: string | ((item: FormValues) => string);
  showDeleteButton?: boolean;
};

export function ListItemSlot(_props: ListItemSlotProps): null {
  return null;
}
```

**Step 2: Create `packages/enforma-mui/src/components/ListFormSlot.tsx`**

```tsx
// packages/enforma-mui/src/components/ListFormSlot.tsx
import { type ReactNode } from 'react';

export type ListFormSlotMode = 'CREATE' | 'UPDATE' | 'DISPLAY';

export type ListFormSlotProps = {
  mode?: ListFormSlotMode;
  showDeleteButton?: boolean;
  children: ReactNode;
};

export function ListFormSlot(_props: ListFormSlotProps): null {
  return null;
}
```

**Step 3: Commit**

```bash
git add packages/enforma-mui/src/components/ListItemSlot.tsx \
        packages/enforma-mui/src/components/ListFormSlot.tsx
git commit -m "feat: add ListItemSlot and ListFormSlot config components"
```

---

### Task 3: Write failing tests for MUI List

**Files:**
- Create: `packages/enforma-mui/src/components/List.test.tsx`

Write the full test file before the implementation exists. Tests will fail with import errors.

**Step 1: Create `packages/enforma-mui/src/components/List.test.tsx`**

```tsx
// packages/enforma-mui/src/components/List.test.tsx
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Form, clearRegistry, registerComponents } from 'enforma';
import { TextInput } from './TextInput';
import { List } from './List';

beforeEach(() => {
  clearRegistry();
  registerComponents({ TextInput });
});

const defaultProps = {
  bind: 'items',
  defaultItem: { name: '' },
};

function renderList(
  listProps: Partial<typeof defaultProps & { disabled?: boolean }> = {},
  extraChildren?: React.ReactNode,
) {
  const onChange = vi.fn();
  render(
    <Form values={{ items: [{ name: 'Alice' }, { name: 'Bob' }] }} onChange={onChange}>
      <List {...defaultProps} {...listProps}>
        <List.Item title="name" />
        <List.Form>
          <TextInput bind="name" label="Name" />
        </List.Form>
        {extraChildren}
      </List>
    </Form>,
  );
  return { onChange };
}

describe('MUI List — rows', () => {
  it('renders one row per array item showing the title field value', () => {
    renderList();
    expect(screen.getByText('Alice')).toBeInTheDocument();
    expect(screen.getByText('Bob')).toBeInTheDocument();
  });

  it('renders a subtitle when List.Item has subtitle prop', () => {
    const onChange = vi.fn();
    render(
      <Form values={{ items: [{ name: 'Alice', email: 'alice@example.com' }] }} onChange={onChange}>
        <List {...defaultProps}>
          <List.Item title="name" subtitle="email" />
          <List.Form>
            <TextInput bind="name" label="Name" />
          </List.Form>
        </List>
      </Form>,
    );
    expect(screen.getByText('alice@example.com')).toBeInTheDocument();
  });

  it('renders an Add button when not disabled', () => {
    renderList();
    expect(screen.getByRole('button', { name: /add/i })).toBeInTheDocument();
  });

  it('does not render an Add button when disabled', () => {
    renderList({ disabled: true });
    expect(screen.queryByRole('button', { name: /add/i })).not.toBeInTheDocument();
  });
});

describe('MUI List — row delete button', () => {
  it('does not show delete buttons by default', () => {
    renderList();
    expect(screen.queryByRole('button', { name: /delete/i })).not.toBeInTheDocument();
  });

  it('shows delete icon buttons when List.Item has showDeleteButton', () => {
    const onChange = vi.fn();
    render(
      <Form values={{ items: [{ name: 'Alice' }] }} onChange={onChange}>
        <List {...defaultProps}>
          <List.Item title="name" showDeleteButton />
          <List.Form>
            <TextInput bind="name" label="Name" />
          </List.Form>
        </List>
      </Form>,
    );
    expect(screen.getByRole('button', { name: /delete/i })).toBeInTheDocument();
  });

  it('removes the item when the row delete button is clicked', async () => {
    const onChange = vi.fn();
    render(
      <Form values={{ items: [{ name: 'Alice' }, { name: 'Bob' }] }} onChange={onChange}>
        <List {...defaultProps}>
          <List.Item title="name" showDeleteButton />
          <List.Form>
            <TextInput bind="name" label="Name" />
          </List.Form>
        </List>
      </Form>,
    );
    const deleteButtons = screen.getAllByRole('button', { name: /delete/i });
    await userEvent.click(deleteButtons[0]!);
    expect(onChange).toHaveBeenLastCalledWith(
      expect.objectContaining({ items: [{ name: 'Bob' }] }),
      expect.anything(),
    );
  });
});

describe('MUI List — Add flow', () => {
  it('opens a dialog when Add is clicked', async () => {
    renderList();
    await userEvent.click(screen.getByRole('button', { name: /add/i }));
    expect(await screen.findByRole('dialog')).toBeInTheDocument();
  });

  it('dialog contains an empty form for the new item', async () => {
    renderList();
    await userEvent.click(screen.getByRole('button', { name: /add/i }));
    await screen.findByRole('dialog');
    expect(screen.getByLabelText('Name')).toHaveValue('');
  });

  it('appends item to parent store on Confirm', async () => {
    const { onChange } = renderList();
    await userEvent.click(screen.getByRole('button', { name: /add/i }));
    await screen.findByRole('dialog');
    await userEvent.type(screen.getByLabelText('Name'), 'Charlie');
    await userEvent.click(screen.getByRole('button', { name: /confirm/i }));
    await waitFor(() => {
      expect(onChange).toHaveBeenLastCalledWith(
        expect.objectContaining({
          items: [{ name: 'Alice' }, { name: 'Bob' }, { name: 'Charlie' }],
        }),
        expect.anything(),
      );
    });
  });

  it('closes dialog on Confirm', async () => {
    renderList();
    await userEvent.click(screen.getByRole('button', { name: /add/i }));
    await screen.findByRole('dialog');
    await userEvent.click(screen.getByRole('button', { name: /confirm/i }));
    await waitFor(() => {
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });
  });

  it('does NOT write to parent store while typing in the modal', async () => {
    const { onChange } = renderList();
    onChange.mockClear();
    await userEvent.click(screen.getByRole('button', { name: /add/i }));
    await screen.findByRole('dialog');
    await userEvent.type(screen.getByLabelText('Name'), 'Charlie');
    // Parent store should not have been updated
    expect(onChange).not.toHaveBeenCalledWith(
      expect.objectContaining({ items: expect.arrayContaining([{ name: 'Charlie' }]) }),
      expect.anything(),
    );
  });

  it('discards draft on Cancel — parent store unchanged', async () => {
    const { onChange } = renderList();
    onChange.mockClear();
    await userEvent.click(screen.getByRole('button', { name: /add/i }));
    await screen.findByRole('dialog');
    await userEvent.type(screen.getByLabelText('Name'), 'Charlie');
    await userEvent.click(screen.getByRole('button', { name: /cancel/i }));
    await waitFor(() => {
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });
    expect(onChange).not.toHaveBeenCalledWith(
      expect.objectContaining({
        items: expect.arrayContaining([{ name: 'Charlie' }]),
      }),
      expect.anything(),
    );
  });
});

describe('MUI List — Edit flow', () => {
  it('opens a dialog when a row is clicked', async () => {
    renderList();
    await userEvent.click(screen.getByText('Alice'));
    expect(await screen.findByRole('dialog')).toBeInTheDocument();
  });

  it('dialog pre-populates with the clicked item data', async () => {
    renderList();
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    expect(screen.getByLabelText('Name')).toHaveValue('Alice');
  });

  it('updates the item in parent store on Confirm', async () => {
    const { onChange } = renderList();
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    await userEvent.clear(screen.getByLabelText('Name'));
    await userEvent.type(screen.getByLabelText('Name'), 'Alicia');
    await userEvent.click(screen.getByRole('button', { name: /confirm/i }));
    await waitFor(() => {
      expect(onChange).toHaveBeenLastCalledWith(
        expect.objectContaining({
          items: [{ name: 'Alicia' }, { name: 'Bob' }],
        }),
        expect.anything(),
      );
    });
  });

  it('leaves parent store unchanged on Cancel', async () => {
    const { onChange } = renderList();
    onChange.mockClear();
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    await userEvent.clear(screen.getByLabelText('Name'));
    await userEvent.type(screen.getByLabelText('Name'), 'Alicia');
    await userEvent.click(screen.getByRole('button', { name: /cancel/i }));
    await waitFor(() => {
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });
    // No update call with Alicia
    expect(onChange).not.toHaveBeenCalledWith(
      expect.objectContaining({ items: [{ name: 'Alicia' }, { name: 'Bob' }] }),
      expect.anything(),
    );
  });
});

describe('MUI List — modal delete', () => {
  it('does not show a Delete button in modal by default', async () => {
    renderList();
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    expect(screen.queryByRole('button', { name: /^delete$/i })).not.toBeInTheDocument();
  });

  it('shows Delete button in modal when List.Form has showDeleteButton', async () => {
    const onChange = vi.fn();
    render(
      <Form values={{ items: [{ name: 'Alice' }] }} onChange={onChange}>
        <List {...defaultProps}>
          <List.Item title="name" />
          <List.Form showDeleteButton>
            <TextInput bind="name" label="Name" />
          </List.Form>
        </List>
      </Form>,
    );
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    expect(screen.getByRole('button', { name: /^delete$/i })).toBeInTheDocument();
  });

  it('removes item and closes modal when modal Delete is clicked', async () => {
    const onChange = vi.fn();
    render(
      <Form values={{ items: [{ name: 'Alice' }, { name: 'Bob' }] }} onChange={onChange}>
        <List {...defaultProps}>
          <List.Item title="name" />
          <List.Form showDeleteButton>
            <TextInput bind="name" label="Name" />
          </List.Form>
        </List>
      </Form>,
    );
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    await userEvent.click(screen.getByRole('button', { name: /^delete$/i }));
    await waitFor(() => {
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });
    expect(onChange).toHaveBeenLastCalledWith(
      expect.objectContaining({ items: [{ name: 'Bob' }] }),
      expect.anything(),
    );
  });
});

describe('MUI List — disabled', () => {
  it('opens DISPLAY modal (not edit) when a row is clicked on disabled list', async () => {
    render(
      <Form values={{ items: [{ name: 'Alice' }] }} onChange={vi.fn()}>
        <List {...defaultProps} disabled>
          <List.Item title="name" />
          <List.Form mode="UPDATE">
            <TextInput bind="name" label="Name" />
          </List.Form>
          <List.Form mode="DISPLAY">
            <TextInput bind="name" label="Name" disabled />
          </List.Form>
        </List>
      </Form>,
    );
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    // DISPLAY mode should show a Close button, not Confirm/Cancel
    expect(screen.getByRole('button', { name: /close/i })).toBeInTheDocument();
    expect(screen.queryByRole('button', { name: /confirm/i })).not.toBeInTheDocument();
  });

  it('does not show row delete buttons on disabled list even with showDeleteButton', async () => {
    render(
      <Form values={{ items: [{ name: 'Alice' }] }} onChange={vi.fn()}>
        <List {...defaultProps} disabled>
          <List.Item title="name" showDeleteButton />
          <List.Form>
            <TextInput bind="name" label="Name" />
          </List.Form>
        </List>
      </Form>,
    );
    expect(screen.queryByRole('button', { name: /delete/i })).not.toBeInTheDocument();
  });
});

describe('MUI List — mode fallback', () => {
  it('uses untyped List.Form as fallback when no mode-specific form exists', async () => {
    renderList(); // List.Form has no mode prop — used for both CREATE and UPDATE
    await userEvent.click(screen.getByText('Alice'));
    await screen.findByRole('dialog');
    expect(screen.getByLabelText('Name')).toHaveValue('Alice');
  });
});
```

**Step 2: Run tests — expect failures**

```bash
pnpm --filter enforma-mui test -- List
```

Expected: test file fails to compile because `'./List'` does not exist yet.

---

### Task 4: Create MUI `List` main component

**Files:**
- Create: `packages/enforma-mui/src/components/List.tsx`

**Step 1: Create `packages/enforma-mui/src/components/List.tsx`**

```tsx
// packages/enforma-mui/src/components/List.tsx
import { useState, type ReactNode } from 'react';
import React from 'react';
import {
  List as MuiList,
  ListItemButton,
  ListItemText,
  ListItemAvatar,
  Avatar,
  Button,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
} from '@mui/material';
import { Form, type FormValues, useListState } from 'enforma';
import { ListItemSlot, type ListItemSlotProps } from './ListItemSlot';
import { ListFormSlot, type ListFormSlotProps, type ListFormSlotMode } from './ListFormSlot';

type ListProps = {
  bind: string;
  defaultItem: Record<string, unknown>;
  disabled?: boolean;
  children: ReactNode;
};

type ModalState =
  | { open: false }
  | { open: true; index: number; mode: ListFormSlotMode };

function resolveForm(
  forms: ListFormSlotProps[],
  mode: ListFormSlotMode,
): ListFormSlotProps | undefined {
  return forms.find((f) => f.mode === mode) ?? forms.find((f) => f.mode === undefined);
}

function evalProp(
  prop: string | ((item: FormValues) => string),
  item: unknown,
): string {
  if (typeof prop === 'function') return prop(item as FormValues);
  return String((item as FormValues)[prop] ?? '');
}

function ListMain({ bind, defaultItem, disabled = false, children }: ListProps) {
  const { arr, keys, append, remove, update } = useListState(bind, defaultItem);
  const [modal, setModal] = useState<ModalState>({ open: false });
  const [draftValues, setDraftValues] = useState<FormValues>({});

  // Parse slot children
  let itemSlot: ListItemSlotProps | undefined;
  const formSlots: ListFormSlotProps[] = [];
  React.Children.forEach(children, (child) => {
    if (!React.isValidElement(child)) return;
    if (child.type === ListItemSlot) {
      itemSlot = child.props as ListItemSlotProps;
    } else if (child.type === ListFormSlot) {
      formSlots.push(child.props as ListFormSlotProps);
    }
  });

  const openModal = (index: number, mode: ListFormSlotMode) => {
    const draft =
      mode === 'CREATE'
        ? { ...defaultItem }
        : { ...(arr[index] as Record<string, unknown>) };
    setDraftValues(draft);
    setModal({ open: true, index, mode });
  };

  const handleConfirm = () => {
    if (!modal.open) return;
    if (modal.mode === 'CREATE') {
      append(draftValues as Record<string, unknown>);
    } else {
      update(modal.index, draftValues as Record<string, unknown>);
    }
    setModal({ open: false });
  };

  const handleCancel = () => {
    setModal({ open: false });
  };

  const handleDelete = (index: number) => {
    remove(index);
    setModal({ open: false });
  };

  const activeForm = modal.open ? resolveForm(formSlots, modal.mode) : undefined;

  const dialogTitle = modal.open
    ? modal.mode === 'CREATE'
      ? 'Add item'
      : modal.mode === 'UPDATE'
        ? 'Edit item'
        : 'View item'
    : '';

  return (
    <>
      <MuiList>
        {arr.map((item, index) => (
          <ListItemButton
            key={keys[index]}
            onClick={() => {
              openModal(index, disabled ? 'DISPLAY' : 'UPDATE');
            }}
          >
            {itemSlot?.avatar !== undefined && (
              <ListItemAvatar>
                <Avatar src={evalProp(itemSlot.avatar, item)} />
              </ListItemAvatar>
            )}
            {itemSlot !== undefined && (
              <ListItemText
                primary={evalProp(itemSlot.title, item)}
                secondary={
                  itemSlot.subtitle !== undefined
                    ? evalProp(itemSlot.subtitle, item)
                    : undefined
                }
              />
            )}
            {itemSlot?.showDeleteButton === true && !disabled && (
              <IconButton
                edge="end"
                aria-label="delete"
                size="small"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDelete(index);
                }}
              >
                ✕
              </IconButton>
            )}
          </ListItemButton>
        ))}
      </MuiList>

      {!disabled && (
        <Button
          onClick={() => {
            openModal(arr.length, 'CREATE');
          }}
        >
          Add
        </Button>
      )}

      <Dialog open={modal.open} onClose={handleCancel}>
        <DialogTitle>{dialogTitle}</DialogTitle>
        <DialogContent>
          {modal.open && activeForm !== undefined && (
            <Form
              values={draftValues}
              onChange={(v) => {
                setDraftValues(v);
              }}
              aria-label={dialogTitle}
            >
              {activeForm.children}
            </Form>
          )}
        </DialogContent>
        <DialogActions>
          {modal.open &&
            activeForm?.showDeleteButton === true &&
            modal.mode !== 'CREATE' &&
            !disabled && (
              <Button
                color="error"
                onClick={() => {
                  if (modal.open) handleDelete(modal.index);
                }}
              >
                Delete
              </Button>
            )}
          {modal.open && modal.mode !== 'DISPLAY' && (
            <>
              <Button onClick={handleCancel}>Cancel</Button>
              <Button onClick={handleConfirm} variant="contained">
                Confirm
              </Button>
            </>
          )}
          {modal.open && modal.mode === 'DISPLAY' && (
            <Button onClick={handleCancel}>Close</Button>
          )}
        </DialogActions>
      </Dialog>
    </>
  );
}

export const List = Object.assign(ListMain, {
  Item: ListItemSlot,
  Form: ListFormSlot,
});
```

**Step 2: Run tests**

```bash
pnpm --filter enforma-mui test -- List
```

Expected: all tests pass. If any fail, debug before continuing.

**Step 3: Run full test suite + lint**

```bash
pnpm test
pnpm lint
```

Expected: no failures, no lint errors.

**Step 4: Commit**

```bash
git add packages/enforma-mui/src/components/List.tsx \
        packages/enforma-mui/src/components/List.test.tsx
git commit -m "feat: add MUI List compound component with modal CRUD"
```

---

### Task 5: Export and wire up

**Files:**
- Modify: `packages/enforma-mui/src/index.ts`
- Modify: `apps/demo/src/App.tsx`

**Step 1: Export `List` from `packages/enforma-mui/src/index.ts`**

Add `List` to the bundles and individual exports. The final `index.ts`:

```ts
import type { EnformaComponentRegistry } from 'enforma';
import { TextInput } from './components/TextInput';
import { Fieldset } from './components/Fieldset';
import { List } from './components/List';
import { ClassicProvider } from './context/ClassicProvider';
import { OutlinedProvider } from './context/OutlinedProvider';
import { StandardProvider } from './context/StandardProvider';

export const classic: Partial<EnformaComponentRegistry> = {
  TextInput,
  Fieldset,
  FormWrap: ClassicProvider,
};

export const outlined: Partial<EnformaComponentRegistry> = {
  TextInput,
  Fieldset,
  FormWrap: OutlinedProvider,
};

export const standard: Partial<EnformaComponentRegistry> = {
  TextInput,
  Fieldset,
  FormWrap: StandardProvider,
};

export { TextInput, Fieldset, List };
export { ClassicProvider, OutlinedProvider, StandardProvider };
export type { MuiVariant } from './context/MuiVariantContext';
```

Note: `List` is NOT added to the bundles (`classic`, `outlined`, `standard`) because its sub-component API (`List.Item`, `List.Form`) is specific to the MUI implementation and accessed via direct import, not the registry.

**Step 2: Update demo to use MUI List**

In `apps/demo/src/App.tsx`:
- Add `import { List } from 'enforma-mui';` at the top
- Replace the existing `<Enforma.List>` section with the MUI compound component

The List section (around line 171–184) becomes:

```tsx
<h2>List</h2>
<p style={{ color: '#555', marginBottom: '1rem' }}>
  Repeated sections driven by an array. Click a row to edit in a modal.
</p>

<Enforma.Form values={listValues} onChange={setListValues} aria-label="list demo form">
  <List bind="members" defaultItem={{ name: '' }}>
    <List.Item title="name" showDeleteButton />
    <List.Form showDeleteButton>
      <Enforma.TextInput bind="name" label="Name" />
    </List.Form>
  </List>
</Enforma.Form>
```

**Step 3: Run full suite**

```bash
pnpm test
pnpm lint
```

Expected: all tests pass, no lint errors or warnings.

**Step 4: Commit**

```bash
git add packages/enforma-mui/src/index.ts apps/demo/src/App.tsx
git commit -m "feat: export MUI List from enforma-mui, update demo"
```
